# Main Memory Management

- pair of base (lowest memory addr, starting point) and limit (starting from base, how many addresses can we access) registers used to define addr space. all mem access should be in this limits
- highest addr = base + limit - 1
- accessed memory: base addr <= memory addr <= highest addr (assumption for this condition is that memory is a contigous chunk)

## Logical vs Physical Addr Space

- logical addr: gen by CPU (virtual addr)
  - logical addr space: set of all logical addr generated by a program
- physical addr: addr seen by memory unit
  - set of all the physical addr _corresponding to logical addr_ generated by the program

## Memory Management Unit

- device to map logical to physical addr
- user program never sees physical addr, only logical addr

## Swapping

- move a process out of main memory (_swap_) into a _backing store_ (a fast large storage to accommodate copies of all memory images for all users)
- sys maintains a ready queue of process ready (process remains in ready queue) to run with memory images on disk
- major part of swap time is transfer time => context switch time v high
- only done when free mem is v low
- not done much -> more disk r/w -> lower sys throughput

## Contigous Memory Allocation

- variable sized parition sizes -> sized acc to given process' needs (efficiency reasons)
- holes -> blocks of avaiable memory scattered throughout memory
  - process when arrives is given a hole large enough to accomodate it
  - as process exits, and frees it's partition, free partitions may be merged
- OS maintains info on 1. allocated partitions and 2. free partitions (holes)

### Dynamic storage-allocation problem

- 3 strategies to allocate hole to an incoming process
  - first fit: allocate first big enough hole
  - best fit: smallest hole big enough (search through entire list) -> produces smallest leftover hole
  - worst fit: biggest hole (search through entire list) -> produces largest leftover hole
- first fit & best fit work better than worst fit for speed & storage utilisation

## Fragmentation

- external fragmentation: total mem space exists to satisfy a request but it is not contiguous
- reduced by **compaction**
  - shuffle mem contents to place all free mem together in one large block
  - during this time usually system is offline (because memory addresses are changing, prog execution has to stop)
- let logical addr space be non-contiguous, can do without compaction
- internal fragmentation: allocated mem > requested mem (because say we are only allowed to allocate memory in multiples of certain chunks) => size diff is memory internal to a partition but not being used

## Segmentation

- prog -> collection of variable sized segments
- segment -> **logical unit** like main prog, stack, symbol table, etx
- scheme supports user view of memory
- logical addr space -> collection of segments
- different segments need not be contiguous, each segment is contigous

### Segmentation Arch

- logical addr: tuple <segment-number, offset>
  - each segment has multiple address mapping to real objects and offset is the distance from the base addr
- seg table: map logical addr to physical addr (entries = number of segments)
  - seg base: starting physical addr where seg resides in memory
  - seg limit: length of seg
- largest accessible addr in a segment = base + lim - 1
- seg-table base register (STBR) -> point to segment table's location in memory
- seg-table length register (STLR) -> indicates number of segments used by a prog
- has issues of external fragmentation, compaction helps
  - sometimes there may not be enough space to load segments of a process
- seg numbering always starts from 0
- (in the diagram in the slides, d -> offset value, <s, d> is the tuple mentioned above)
  - if d >= lim -> addressing error
- physical addr = base + d (offset)
- during context switch, STBR & STLR values in the registers are also swapped
- each process has it's unique segment table
- first location in a segment has offset 0
